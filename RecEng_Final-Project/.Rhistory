knitr::opts_chunk$set(echo = TRUE)
groceries_summary <- summary(Groceries)
data("Groceries")
groceriesDataset <- as(Groceries, "binaryRatingMatrix")
data("Groceries")
groceriesDataset <- as(Groceries, "binaryRatingMatrix")
# Install all packages
install_missing_packages <- function(x) if (sum(!x %in% installed.packages())) install.packages(x[!x %in% installed.packages()])
install_missing_packages(c("dplyr", "class", "recommenderlab", "shiny"))
data("Groceries")
groceriesDataset <- as(Groceries, "binaryRatingMatrix")
data("Groceries")
# Install all packages
install_missing_packages <- function(x) if (sum(!x %in% installed.packages())) install.packages(x[!x %in% installed.packages()])
install_missing_packages(c("dplyr", "class", "recommenderlab", "shiny"))
# Load/Install packages
if(!"dplyr" %in% installed.packages()) {install.packages("dplyr")}
library(dplyr)
if(!"class" %in% installed.packages()) {install.packages("class")}
library(class)
if(!"recommenderlab" %in% installed.packages()) {install.packages("recommenderlab")}
library(recommenderlab)
if(!"shiny" %in% installed.packages()) {install.packages("shiny")}
library(shiny)
data("Groceries")
groceriesDataset <- as(Groceries, "binaryRatingMatrix")
#str(groceriesDataset)
groceries_summary <- summary(Groceries)
groceries_summary
plot(groceries_summary@lengths)
itemFrequencyPlot(Groceries, topN = 20)
recommenderRegistry$get_entries(dataType = "binaryRatingMatrix")
vector_k <- c(100,150,169,300,350,400)
models_to_evaluate <- lapply(vector_k, function(k){
list(name = "IBCF",
param = list(method = "Jaccard", k = k))
})
names(models_to_evaluate) <- paste0("IBCF_k_", vector_k)
resultsIBCF <- evaluate(esSplitGroc, models_to_evaluate, type = "topNList", n=c(1, 5, 10, 15, 50, 100))
knitr::opts_chunk$set(echo = TRUE)
# Load/Install packages
if(!"dplyr" %in% installed.packages()) {install.packages("dplyr")}
library(dplyr)
if(!"class" %in% installed.packages()) {install.packages("class")}
library(class)
if(!"recommenderlab" %in% installed.packages()) {install.packages("recommenderlab")}
library(recommenderlab)
if(!"shiny" %in% installed.packages()) {install.packages("shiny")}
library(shiny)
data("Groceries")
groceriesDataset <- as(Groceries, "binaryRatingMatrix")
#str(groceriesDataset)
groceries_summary <- summary(Groceries)
groceries_summary
plot(groceries_summary@lengths)
itemFrequencyPlot(Groceries, topN = 20)
# 80-20 for train and test set
esSplitGroc <- evaluationScheme(groceriesDataset, method="split", train=0.80, given = -1)
algorithms <- list(
"random" = list(name="RANDOM", param=NULL),
"popular" = list(name="POPULAR", param=NULL),
"UBCF" = list(name="UBCF", param=list(nn=500)),
"IBCFJac" = list(name="IBCF", param=list(method = "Jaccard",
k=500)),
"AR" = list(name="AR", param = list(support = 0.001, conf = 0.3, maxlen=5))
)
resultsGroc <- evaluate(esSplitGroc, algorithms, type = "topNList", n=c(1, 5, 10, 15, 50, 100))
plot(resultsGroc, annotate=c(1,2))
vector_k <- c(100,150,169,300,350,400)
models_to_evaluate <- lapply(vector_k, function(k){
list(name = "IBCF",
param = list(method = "Jaccard", k = k))
})
names(models_to_evaluate) <- paste0("IBCF_k_", vector_k)
resultsIBCF <- evaluate(esSplitGroc, models_to_evaluate, type = "topNList", n=c(1, 5, 10, 15, 50, 100))
plot(resultsIBCF, annotate=c(1,2))
recAr <- Recommender(getData(esSplitGroc,"train"), method = "AR", parameter = list(support = 0.001, conf = 0.3, maxlen = 5))
recIBCFJaccard <- Recommender(getData(esSplitGroc,"train"), method = "IBCF", parameter = list(method = "Jaccard", k = 300))
recUBCF <- Recommender(getData(esSplitGroc, "train"), method = "UBCF", parameter = list(method="cosine",nn=50))
recPopular <- Recommender(getData(esSplitGroc, "train"), method = "POPULAR")
pAR <- predict(recAr, getData(esSplitGroc, "known"))
pIBCFJaccard <- predict(recIBCFJaccard, getData(esSplitGroc, "known"))
pUBCF <- predict(recUBCF, getData(esSplitGroc, "known"))
pPopular <- predict(recPopular, getData(esSplitGroc, "known"))
calcPredictionAccuracy(pAR, getData(esSplitGroc, "unknown"), given = -1)
calcPredictionAccuracy(pIBCFJaccard, getData(esSplitGroc, "unknown"), given = -1)
calcPredictionAccuracy(pUBCF, getData(esSplitGroc, "unknown"), given=-1)
calcPredictionAccuracy(pPopular, getData(esSplitGroc, "unknown"), given = -1)
arGroceriesModel <- getModel(recAr)$rule_base
summary(arGroceriesModel)
inspect(head(sort(arGroceriesModel, by="lift", decreasing=TRUE), 35))
inspect(head(sort(arGroceriesModel, by="confidence", decreasing=TRUE), 35))
inspect(head(sort(arGroceriesModel, by="support", decreasing=TRUE), 35))
knitr::opts_chunk$set(echo = TRUE)
# Load/Install packages
if(!"dplyr" %in% installed.packages()) {install.packages("dplyr")}
library(dplyr)
if(!"class" %in% installed.packages()) {install.packages("class")}
library(class)
if(!"recommenderlab" %in% installed.packages()) {install.packages("recommenderlab")}
library(recommenderlab)
if(!"shiny" %in% installed.packages()) {install.packages("shiny")}
library(shiny)
data("Groceries")
groceriesDataset <- as(Groceries, "binaryRatingMatrix")
#str(groceriesDataset)
groceries_summary <- summary(Groceries)
groceries_summary
plot(groceries_summary@lengths)
itemFrequencyPlot(Groceries, topN = 20)
recommenderRegistry$get_entries(dataType = "binaryRatingMatrix")
# 80-20 for train and test set
esSplitGroc <- evaluationScheme(groceriesDataset, method="split", train=0.80, given = -1)
algorithms <- list(
"random" = list(name="RANDOM", param=NULL),
"popular" = list(name="POPULAR", param=NULL),
"UBCF" = list(name="UBCF", param=list(nn=500)),
"IBCFJac" = list(name="IBCF", param=list(method = "Jaccard",
k=500)),
"AR" = list(name="AR", param = list(support = 0.001, conf = 0.3, maxlen=5))
)
resultsGroc <- evaluate(esSplitGroc, algorithms, type = "topNList", n=c(1, 5, 10, 15, 50, 100))
plot(resultsGroc, annotate=c(1,2))
vector_k <- c(100,150,169,300,350,400)
models_to_evaluate <- lapply(vector_k, function(k){
list(name = "IBCF",
param = list(method = "Jaccard", k = k))
})
names(models_to_evaluate) <- paste0("IBCF_k_", vector_k)
resultsIBCF <- evaluate(esSplitGroc, models_to_evaluate, type = "topNList", n=c(1, 5, 10, 15, 50, 100))
plot(resultsIBCF, annotate=c(1,2))
recAr <- Recommender(getData(esSplitGroc,"train"), method = "AR", parameter = list(support = 0.001, conf = 0.3, maxlen = 5))
recIBCFJaccard <- Recommender(getData(esSplitGroc,"train"), method = "IBCF", parameter = list(method = "Jaccard", k = 300))
recUBCF <- Recommender(getData(esSplitGroc, "train"), method = "UBCF", parameter = list(method="cosine",nn=50))
recPopular <- Recommender(getData(esSplitGroc, "train"), method = "POPULAR")
pAR <- predict(recAr, getData(esSplitGroc, "known"))
pIBCFJaccard <- predict(recIBCFJaccard, getData(esSplitGroc, "known"))
pUBCF <- predict(recUBCF, getData(esSplitGroc, "known"))
pPopular <- predict(recPopular, getData(esSplitGroc, "known"))
calcPredictionAccuracy(pAR, getData(esSplitGroc, "unknown"), given = -1)
calcPredictionAccuracy(pIBCFJaccard, getData(esSplitGroc, "unknown"), given = -1)
calcPredictionAccuracy(pUBCF, getData(esSplitGroc, "unknown"), given=-1)
calcPredictionAccuracy(pPopular, getData(esSplitGroc, "unknown"), given = -1)
arGroceriesModel <- getModel(recAr)$rule_base
summary(arGroceriesModel)
inspect(head(sort(arGroceriesModel, by="lift", decreasing=TRUE), 35))
inspect(head(sort(arGroceriesModel, by="confidence", decreasing=TRUE), 35))
inspect(head(sort(arGroceriesModel, by="support", decreasing=TRUE), 35))
View(Groceries)
Groceries@data
Groceries@data
df<-Groceries@data
View(df)
knitr::opts_chunk$set(echo = TRUE)
# Load/Install packages
if(!"dplyr" %in% installed.packages()) {install.packages("dplyr")}
library(dplyr)
if(!"class" %in% installed.packages()) {install.packages("class")}
library(class)
if(!"recommenderlab" %in% installed.packages()) {install.packages("recommenderlab")}
library(recommenderlab)
if(!"shiny" %in% installed.packages()) {install.packages("shiny")}
library(shiny)
data("Groceries")
groceriesDataset <- as(Groceries, "binaryRatingMatrix")
#str(groceriesDataset)
groceries_summary <- summary(Groceries)
groceries_summary
plot(groceries_summary@lengths)
itemFrequencyPlot(Groceries, topN = 20)
recommenderRegistry$get_entries(dataType = "binaryRatingMatrix")
# 80-20 for train and test set
esSplitGroc <- evaluationScheme(groceriesDataset, method="split", train=0.80, given = -1)
algorithms <- list(
"random" = list(name="RANDOM", param=NULL),
"popular" = list(name="POPULAR", param=NULL),
"UBCF" = list(name="UBCF", param=list(nn=500)),
"IBCFJac" = list(name="IBCF", param=list(method = "Jaccard",
k=500)),
"AR" = list(name="AR", param = list(support = 0.001, conf = 0.3, maxlen=5))
)
resultsGroc <- evaluate(esSplitGroc, algorithms, type = "topNList", n=c(1, 5, 10, 15, 50, 100))
plot(resultsGroc, annotate=c(1,2))
vector_k <- c(100,150,169,300,350,400)
models_to_evaluate <- lapply(vector_k, function(k){
list(name = "IBCF",
param = list(method = "Jaccard", k = k))
})
names(models_to_evaluate) <- paste0("IBCF_k_", vector_k)
resultsIBCF <- evaluate(esSplitGroc, models_to_evaluate, type = "topNList", n=c(1, 5, 10, 15, 50, 100))
plot(resultsIBCF, annotate=c(1,2))
recAr <- Recommender(getData(esSplitGroc,"train"), method = "AR", parameter = list(support = 0.001, conf = 0.3, maxlen = 5))
recIBCFJaccard <- Recommender(getData(esSplitGroc,"train"), method = "IBCF", parameter = list(method = "Jaccard", k = 300))
recUBCF <- Recommender(getData(esSplitGroc, "train"), method = "UBCF", parameter = list(method="cosine",nn=50))
recPopular <- Recommender(getData(esSplitGroc, "train"), method = "POPULAR")
pAR <- predict(recAr, getData(esSplitGroc, "known"))
pIBCFJaccard <- predict(recIBCFJaccard, getData(esSplitGroc, "known"))
pUBCF <- predict(recUBCF, getData(esSplitGroc, "known"))
pPopular <- predict(recPopular, getData(esSplitGroc, "known"))
calcPredictionAccuracy(pAR, getData(esSplitGroc, "unknown"), given = -1)
calcPredictionAccuracy(pIBCFJaccard, getData(esSplitGroc, "unknown"), given = -1)
calcPredictionAccuracy(pUBCF, getData(esSplitGroc, "unknown"), given=-1)
calcPredictionAccuracy(pPopular, getData(esSplitGroc, "unknown"), given = -1)
arGroceriesModel <- getModel(recAr)$rule_base
summary(arGroceriesModel)
inspect(head(sort(arGroceriesModel, by="lift", decreasing=TRUE), 35))
inspect(head(sort(arGroceriesModel, by="confidence", decreasing=TRUE), 35))
inspect(head(sort(arGroceriesModel, by="support", decreasing=TRUE), 35))
load("bigMovieLense.RData")
str(bigMovieLense)
# On average wow many evaluations per user we have?
mean(rowCounts(bigMovieLense))
min(rowCounts(bigMovieLense))
max(rowCounts(bigMovieLense))
# Which are the evaluations from the first user?
#as(bigMovieLense[1,], "list")
# On average, how much the first user rates?
rowMeans(bigMovieLense[1,])
# Distribution of the ratings
hist(getRatings(bigMovieLense), col = "darkred")
hist(getRatings(normalize(bigMovieLense, method = "Z-score")), main="Z-score Ratings Distribution", col = "DarkRed")
#distribution of how many movies each user has rated
hist(rowCounts(bigMovieLense), breaks = 50, main = "Histogram Rated movies by user", col = "DarkBlue")
# Distribution of the average ratings per movie
hist(colMeans(bigMovieLense), main = "Histogram Average Rating per Movie", col = "DarkGreen")
# Get the different Algorithms that we may apply to our Recommendation Engine
recommenderRegistry$get_entries(dataType = "realRatingMatrix")
MoviesSubset <- bigMovieLense[1:(nrow(bigMovieLense)*0.50),]
set.seed(123)
Multi_evaluate <- evaluationScheme(MoviesSubset, method = "split", train=0.8, given = 5, goodRating = 4)
algorithms <- list(
"random" = list(name="RANDOM", param=NULL),
"popular" = list(name="POPULAR", param=NULL),
"User Based CFnn50" = list(name="UBCF", param=list(nn=50)),
"User Based CFCos" = list(name="UBCF", param=list(method = "Cosine")),
"Item Based CFPea" = list(name="IBCF", param=list(method = "Pearson")),
"ALS" = list(name="ALS", param=list())
)
Multi_results <- evaluate(Multi_evaluate,
method = algorithms,
type = "topNList",
parameter = list(normalize = "Z-Score"),
n=c(1, 5, seq(10,100,10)))
plot(Multi_results, annotate=c(1,2), legend = "topleft")
ratings_results <- evaluate(Multi_evaluate, algorithms, type = "ratings")
plot(ratings_results)
df<-Groceries@data
